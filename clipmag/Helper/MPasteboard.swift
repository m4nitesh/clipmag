//
//  MPasteboard.swift
//  clipmag
//
//  Created by Nitesh Kumar on 25/04/21.
//

import Foundation

import AppKit

class Clipboard {
    
    private let pasteboard = NSPasteboard.general
    private let timerInterval = 1.0
    
    // See http://nspasteboard.org for more details.
    private let ignoredTypes: Set = [
        "org.nspasteboard.TransientType",
        "org.nspasteboard.ConcealedType",
        "org.nspasteboard.AutoGeneratedType"
    ]
    
    private var changeCount: Int
    
    private let supportedTypes: Set = [
        NSPasteboard.PasteboardType.fileURL,
        NSPasteboard.PasteboardType.png,
        NSPasteboard.PasteboardType.string,
        NSPasteboard.PasteboardType.tiff
    ]
    private var enabledTypes: Set<NSPasteboard.PasteboardType> { UserDefaults.standard.enabledPasteboardTypes }
    private var disabledTypes: Set<NSPasteboard.PasteboardType> { supportedTypes.subtracting(enabledTypes) }
    
    private var accessibilityAlert: NSAlert {
        let alert = NSAlert()
        alert.alertStyle = .warning
        alert.messageText = NSLocalizedString("“Clipmag” requires accessibility permission to auto paste.", comment: "")
        alert.informativeText = NSLocalizedString("Grant access to this application in Preferences -> Security & Privacy -> Accessibility -> + Clipmag", comment: "")
        alert.addButton(withTitle: NSLocalizedString("Open System Preferences", comment: ""))
        //        alert.addButton(withTitle: NSLocalizedString("Deny", comment: ""))
        alert.icon = NSImage(named: "NSSecurity")
        return alert
    }
    private var accessibilityAllowed: Bool { AXIsProcessTrustedWithOptions(nil) }
    private let accessibilityURL = URL(
        string: "x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility"
    )
    
    
    private var frontmostApp: (name: String, bundle: String, icon: NSImage)?
    
    
    init() {
        changeCount = pasteboard.changeCount
    }
    
    
    func startListening() {
        
        NSWorkspace.shared.notificationCenter.addObserver(self, selector: #selector(activeApp(sender:)), name: NSWorkspace.didActivateApplicationNotification, object: nil)
        
        Timer.scheduledTimer(timeInterval: timerInterval,
                             target: self,
                             selector: #selector(checkForChangesInPasteboard),
                             userInfo: nil,
                             repeats: true)
        
        
    }
    
    @objc
    private func activeApp(sender: NSNotification) {
        if let info = sender.userInfo,
           let content = info[NSWorkspace.applicationUserInfoKey] as? NSRunningApplication,
           let name = content.localizedName,
           let bundle = content.bundleIdentifier,
           let icon = content.icon
        {
            frontmostApp = (name: name, bundle: bundle, icon: icon)
        }
    }
    
    @objc
    func checkForChangesInPasteboard() {
        guard pasteboard.changeCount != changeCount else {
            return
        }
        
        defer {
            if pasteboard.changeCount != changeCount {
                changeCount = pasteboard.changeCount
            }
        }
        
        guard let fItem = pasteboard.pasteboardItems?.first else {
            return
        }
        
        let applicationId: String = frontmostApp?.bundle ?? ""
        
        var text: String = ""
        var data: Data? = nil
        var pType: NSPasteboard.PasteboardType? = nil
        var urlString: String? = nil
        
        let types = fItem.types
        
        for type in types {
            if type == .fileURL {
                urlString = fItem.string(forType: .fileURL) ?? ""
                pType = NSPasteboard.PasteboardType.fileURL
            }
            if type == .tiff {
                data = fItem.data(forType: .tiff)
                pType = NSPasteboard.PasteboardType.tiff
            }
            if type == .string {
                text = fItem.string(forType: .string) ?? ""
                pType = NSPasteboard.PasteboardType.string
            }
        }
        
        if pType == NSPasteboard.PasteboardType.tiff {
            text = "Image \(NSDate().timeIntervalSince1970)"
        } else {
            if urlString != nil {
                let blkArr = getBulkCopyArr()
                data = stringArrayToData(stringArray: blkArr)
                pType = NSPasteboard.PasteboardType.fileURL
            }
        }
        
        if !isEmptyString(text) {
            _ = PersistenceController.shared.updateOrInsertItem(
                stringData: text.trimmingCharacters(in: .whitespacesAndNewlines),
                applicationId: applicationId,
                data: data,
                pType: pType,
                urlString: urlString
            )
        }
    }
    
    private func getBulkCopyArr() -> [String] {
        var fileUrlArr: [String] = []
        
        for trash in pasteboard.pasteboardItems ?? [] {
            if let fUrl = trash.string(forType: .fileURL) {
                fileUrlArr.append(fUrl)
            }
        }
        return fileUrlArr
        
    }
    
    func copy(_ item: HistoryItem) {
        
        pasteboard.clearContents()
        let pType = NSPasteboard.PasteboardType.init(item.pType ?? NSPasteboard.PasteboardType.string.rawValue)
        pasteboard.setString(item.stringData!, forType: .string)
        if pType == .fileURL {
            if let data = item.binaryData {
                let itemsToPaste = dataToStringArray(data) ?? []
                let imgUrls = itemsToPaste.map() { item in
                    return NSPasteboardItem.init(pasteboardPropertyList: item, ofType: .fileURL)
                }
                pasteboard.writeObjects(imgUrls as! [NSPasteboardWriting])
            } else {
                pasteboard.setString(item.urlString!, forType: .fileURL)
            }
            
        } else if pType == .tiff {
            pasteboard.setData(item.binaryData, forType: .tiff)
        }
        paste()
    }
    
    func paste() {
        NSApp.hide(nil)
        guard accessibilityAllowed else {
            // Show accessibility window async to allow menu to close.
            DispatchQueue.main.async(execute: showAccessibilityWindow)
            return
        }
        
        let event1 = CGEvent(keyboardEventSource: nil, virtualKey: 0x09, keyDown: true); // cmd-v down
        event1?.flags = CGEventFlags.maskCommand;
        event1?.post(tap: CGEventTapLocation.cghidEventTap);
        
        let event2 = CGEvent(keyboardEventSource: nil, virtualKey: 0x09, keyDown: false) // cmd-v up
        event2?.flags = CGEventFlags.maskCommand
        event2?.post(tap: CGEventTapLocation.cghidEventTap)
    }
    
    
    private func isEmptyString(_ str: String) -> Bool {
        return str.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    
    private func shouldIgnore(_ types: Set<NSPasteboard.PasteboardType>) -> Bool {
        let ignoredTypes = self.ignoredTypes
            .union(UserDefaults.standard.ignoredPasteboardTypes)
            .map({ NSPasteboard.PasteboardType($0) })
        return types.isDisjoint(with: enabledTypes) ||
            !types.isDisjoint(with: ignoredTypes)
    }
    
    
    private func showAccessibilityWindow() {
        if let url = accessibilityURL {
            NSWorkspace.shared.open(url)
        }
    }
    
    
    
}

